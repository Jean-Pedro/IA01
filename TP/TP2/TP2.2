(setq map '((1 12 2)(2 1 3)(3 2 4)(4 3 5)(5 4 8 6)(6 5 7)(7 8 6)(8 7 5)(12 13 1)
            (13 24 12)(15 22)(20 21 29)(21 22 20)(22 27 21 15)(24 25 13)
            (25 36 26 24)(26 25 27)(27 26 22)(29 32 20)(32 29)(36 25)))


(setq horcruxesDescription '(("Journal intime de Tom Jedusor" 
                                (methodeDestruction "Crochet de Basilic"))
                             ("Médaillon de Salazar Serpentard" 
                                (methodeDestruction "Epée de Gryffondor"))
                             ("Bague de Gaunt" 
                                (methodeDestruction "Epée de Gryffondor"))
                             ("Coupe de Helga Poufsouffle" 
                                (methodeDestruction "Crochet de Basilic"))
                             ("Nagini" 
                                (methodeDestruction "Epée de Gryffondor"))
                             ("Diadème de Rowena Serdaigle" 
                                (methodeDestruction "Feudeymon"))))

(setq horcruxesMap '((8 "Journal intime de Tom Jedusor")
                     (12 "Médaillon de Salazar Serpentard")
                     (15 "Bague de Gaunt")
                     (22 "Coupe de Helga Poufsouffle")
                     (26 "Nagini")
                     (29 "Diadème de Rowena Serdaigle")))

(setq armesMap '((3 "Crochet de Basilic")
                 (32 "Feudeymon")
                 (25 "Epée de Gryffondor")
                 (20 "Sortilège de la Mort")))



(defun successeurs-valides (case carte chemin)
  (if (and (and (numberp case) (listp carte)) (listp chemin)) ; vérification des paramètres
      (let ((succ (cdr (assoc case carte)))) ; on ajoute tous les successeurs de case
        (remove-if #'(lambda (x) (member x chemin)) succ)) ; on retire ceux déjà dans chemin
    "Erreur de type dans la saisie des paramètres"
    )
  )




(defun methodeDestruction (horc horcDesc)
  (if (and (stringp horc)(listp horcDesc)) ; vérification des paramètres
      (let ((desc (cadr (assoc horc horcDesc :test #'string=))))
        (if desc
            (cadr desc))
        )
    "Erreur de type dans la saisie des paramètres"
    ))



(defun hasBonneArme (horc listeM horcDesc)
  (if (and (and (stringp horc)(listp listeM))(listp horcDesc)) ; vérification des paramètres
      (let ((methode (methodeDestruction horc horcDesc))) ; on récupère la méthode de destruction de horc
        (if (member methode listeM :test #'string=) ; on teste si cette méthode est dans la liste des méthodes possédées
            T))
    "Erreur de type dans la saisie des paramètres"
    )
  )



(defun recherche-harry (caseDepart map horcruxesMap armesMap horcruxesDescription)
  (if (and (and (and (and (and (numberp caseDepart) (listp map)) (listp horcruxesDescription)) (listp armesMap)) (listp horcruxesMap))) ; vérification des paramètres
      (progn 
        (let ((case 'nil) 
              (chemin '())
              (cheminGeneral '())
              (horcDetruits '()) 
              (armesCollectees '()) 
              (truc (successeurs-valides caseDepart map '())) 
              (succ nil)
              (armeSurCase nil) 
              (prof -1)
              (horcruxeSurCase (assoc caseDepart horcruxesMap)))
          (push caseDepart truc)
          (loop while truc
              do (progn
                   (setq chemin (append chemin (list (car truc))))
                   (setq cheminGeneral (append cheminGeneral (list (car truc))))
                   (print chemin)
                   (print cheminGeneral)
                   (setq case (pop truc))
                   
                   (setq prof (+ prof 1))
                   (print prof)
                   (setq armeSurCase (cadr (assoc case armesMap)))
                   (if (and armeSurCase (not (member armeSurCase armesCollectees :test #'string=))) ; test de s'il y a une arme que l'on ne possède pas
                       (progn
                         (push armeSurCase armesCollectees) ; ajoute de l'arme dans la liste des possédées
                         (format t "Harry Potter a trouvé ~a~%" armeSurCase)))
                   
                   (setq succ (successeurs-valides case map chemin))
                   (if (and (< prof 7) succ)                       
                         (dolist (x (reverse succ))
                           (push x truc))
                     (progn
                       (setq chemin (backtracking chemin truc map))
                       (setq prof (- (length chemin) 1))
                     ))))

          armesCollectees))))








(defun backtracking (chemin successeurs map)
  (let ((truc (reverse chemin)) (truc2 chemin))
    (loop while (not (member (car successeurs) (successeurs-valides (car truc) map chemin))) do
          (pop truc)

)
    (reverse truc)))


(recherche-harry 1 map horcruxesDescription armesMap horcruxesMap)


